/*
 * Copyright (C) 2012-2017  Online-Go.com
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* This code was derived from https://github.com/billneff79/d3-stock which
 * is a d3.js v4 port of https://github.com/arnauddri/d3-stock */

import * as d3 from "d3";
import * as moment from "moment";
import * as React from "react";
import * as data from "data";
import {Link} from "react-router-dom";
import {termination_socket} from 'sockets';
import {_, pgettext, interpolate} from "translate";
import {PersistentElement} from 'PersistentElement';
import {AnalysisEntry, makeAnalysisEntry} from './AnalysisEntry';


interface AnalysisPredictionChartProperties {
    entries: Array<AnalysisEntry>;
}

const date_bisector = d3.bisector((d:AnalysisEntry) => { return d.move; }).left;
const margin   = {top: 30, right: 20, bottom: 100, left: 20};
const chart_min_width = 64;
const chart_height = 283;
const date_legend_width = 70;
const height   = 120

export class AnalysisPredictionChart extends React.Component<AnalysisPredictionChartProperties, any> {
    container = null;
    chart_div;
    svg;
    clip;
    resize_debounce;
    prediction_graph;
    legend;
    range_label;
    legend_label;
    date_extents;
    predictions:Array<AnalysisEntry>;
    max_games_played_in_a_month:number;
    destroyed = false;

    prediction_x   = d3.scaleLinear();
    prediction_y   = d3.scaleLinear();

    prediction_axis    = d3.axisLeft(this.prediction_y);

    prediction_line = d3.line<AnalysisEntry>()
                           //.curve(d3.curveLinear)
                           .curve(d3.curveMonotoneX)
                           .x((d:AnalysisEntry) => this.prediction_x(d.move))
                           .y((d:AnalysisEntry) => this.prediction_y(d.fast_prediction));
    fast_prediction_line = d3.line<AnalysisEntry>()
                           //.curve(d3.curveLinear)
                           .curve(d3.curveMonotoneX)
                           .x((d:AnalysisEntry) => this.prediction_x(d.move))
                           .y((d:AnalysisEntry) => this.prediction_y(d.fast_prediction));

    full_prediction_line = d3.line<AnalysisEntry>()
                           //.curve(d3.curveLinear)
                           .curve(d3.curveMonotoneX)
                           .x((d:AnalysisEntry) => this.prediction_x(d.move))
                           .y((d:AnalysisEntry) => this.prediction_y(d.full_prediction));

    prediction_chart;
    x_axis_date_labels;
    y_axis_rating_labels;
    helper;
    helperText;
    predictionTooltip;
    mouseArea;
    //verticalCrosshairLine;
    horizontalCrosshairLine;
    timeline_chart;
    timeline_axis_labels;
    brush;
    width;  // whole width of this element
    graph_width; // width of the part where the graph is drawn
    height;

    constructor(props) {
        super(props);
        this.state = {
            loading: false,
            nodata: false,
            hovered_date: null,
            hovered_month: null,
            date_extents: [],
        };
        this.chart_div = $("<div>")[0];
    }
    componentDidMount() {
        this.initialize();
    }
    componentDidUpdate(prevProps, prevState) {
        /*
        if (this.props.playerId !== prevProps.playerId
            || this.props.speed !== prevProps.speed
            || this.props.size  !== prevProps.size
        ) {
            this.refreshData();
        }
        */
        /* TODO */
    }
    componentWillUnmount() {
        this.deinitialize();
    }
    componentWillReceiveProps(nextProps) {
        let size_text = nextProps.size ? `${nextProps.size}x${nextProps.size}` : '';
    }
    shouldComponentUpdate(nextProps, nextState) {
        /* TODO */
        return true;

        //return false;
    }

    setRanges = () => {
        let sizes = this.chart_sizes();

        this.width = sizes.width;
        this.graph_width = 2.0 * sizes.width / 3.0;

        if (this.width <= 768) {
            this.graph_width = this.width;
        }

        this.height = height;

        this.prediction_x.range([0, this.graph_width]);
        //this.timeline_x.range([0, this.graph_width]);
        this.prediction_y.range([height, 0]);
        //this.timeline_y.range([secondary_charts_height, 0]);
        //this.outcomes_y.range([60, 0]);
    }

    initialize() {
        let self = this;

        this.setRanges();

        let width = this.graph_width;
        let height = this.height;

        let boundDataLegendX = (x:number) => {
            return Math.min(width - date_legend_width / 2, Math.max(date_legend_width / 2, x));
        };

        this.svg = d3.select(this.chart_div)
            .append('svg')
            .attr('class', 'chart')
            .attr('width', this.width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom + 60);

        this.clip = this.svg.append('defs')
            .append('clipPath')
            .attr('id', 'clip')
            .append('rect')
            .attr('width', width)
            .attr('height', height);

        this.prediction_graph = this.svg.append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        this.prediction_chart = this.prediction_graph.append('path')
            .attr('class', 'prediction line');

        this.helper = this.prediction_graph.append('g')
            .attr('class', 'chart__helper')
            .style('text-anchor', 'end')
            .attr('transform', 'translate(' + width + ', 0)');

        this.helperText = this.helper.append('text');

        /*
        this.verticalCrosshairLine = this.prediction_graph.append('g')
            .attr('class', 'crosshairs')
            .append('line')
            .style('display', 'none')
            .attr('x0', 0)
            .attr('y0', 0)
            .attr('x1', 0)
            .attr('y1', height);
        */

        this.horizontalCrosshairLine = this.prediction_graph.append('g')
            .attr('class', 'crosshairs')
            .append('line')
            .style('display', 'none')
            .attr('x0', 0)
            .attr('y0', 0)
            .attr('y1', 0)
            .attr('x1', width);

        this.predictionTooltip = this.prediction_graph.append('g')
            .attr('class', 'data-point-circle')
            .append('circle')
            .style('display', 'none')
            .attr('r', 2.5);

        this.mouseArea = this.svg.append('g')
            .append('rect')
            .attr('class', 'overlay')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .attr('width', width)
            .attr('height', height)
            .on('mouseover', () => {
                //this.helper.style('display', null);
                //this.dateLegend.style('display', null);
                //this.predictionTooltip.style('display', null);
                //deviationTooltip.style('display', null);
                //this.verticalCrosshairLine.style('display', null);
                //this.horizontalCrosshairLine.style('display', null);
            })
            .on('mouseout', () => {
                //this.helper.style('display', 'none');
                //this.dateLegend.style('display', 'none');
                //this.predictionTooltip.style('display', 'none');
                //deviationTooltip.style('display', 'none');
                //this.verticalCrosshairLine.style('display', 'none');
                //this.horizontalCrosshairLine.style('display', 'none');
                //this.setState({hovered_date: null});
            })
            .on('mousemove', function() {
                /* tslint:disable */
                let x0 = self.prediction_x.invert(d3.mouse(this as d3.ContainerElement)[0]);
                /* tslint:enable */

                /*
                let i = date_bisector(self.games_by_day, x0, 1);
                let d0 = self.games_by_day[i - 1];
                let d1 = self.games_by_day[i];

                if (!d0 || !d1) {
                    return;
                }

                let d = x0.getTime() - d0.ended.getTime() > d1.ended.getTime() - x0.getTime() ? d1 : d0;
                self.helperText.text(format_date(new Date(d.ended)) + '  ' +
                    interpolate(
                        self.shouldDisplayRankInformation()
                        ? (
                            pgettext( "Glicko-2 rating +- rating deviation text on the ratings chart", "rating: {{rating}} ± {{deviation}} rank: {{rank}} ± {{rank_deviation}}")
                        ) : pgettext( "Glicko-2 rating +- rating deviation text on the ratings chart", "rating: {{rating}} ± {{deviation}}")
                        ,
                        {
                            //rating: Math.floor(d.rating),
                            rating: Math.floor(humble_rating(d.rating, d.deviation)),
                            deviation: Math.round(d.deviation),
                            rank: rankString(bounded_rank(rating_to_rank(humble_rating(d.rating, d.deviation))), true),
                            rank_deviation: (rating_to_rank(d.rating + d.deviation) - rating_to_rank(d.rating)).toFixed(1),
                        }
                    )
                );
                self.dateLegendText.text(format_date(new Date(d.ended)));
                self.dateLegend.attr('transform', 'translate(' + (boundDataLegendX(self.prediction_x(d.ended)) + margin.left)  + ',' + (margin.top + height + 10) + ')');
                self.predictionTooltip.attr('transform', 'translate(' + self.prediction_x(d.ended) + ',' + self.prediction_y(humble_rating(d.rating, d.deviation)) + ')');
                //deviationTooltip.attr('transform', 'translate(' + self.prediction_x(d.ended) + ',' + self.prediction_y(d.rating) + ')');
                //self.verticalCrosshairLine.attr('transform', 'translate(' + self.prediction_x(d.ended) + ', 0)');
                self.horizontalCrosshairLine.attr('transform', 'translate(0, ' + self.prediction_y(humble_rating(d.rating, d.deviation)) + ')');

                self.setState({hovered_date: new Date(d.ended)});
                */
            });

        $(window).on("resize", this.resize as () => void);

        //this.refreshData();
    }
    deinitialize() {
        this.destroyed = true;
        $(window).off("resize", this.resize as () => void);
        if (this.resize_debounce) {
            clearTimeout(this.resize_debounce);
            this.resize_debounce = null;
        }
        this.svg.remove();
        this.container = null;
    }

    /* The area we can draw all of our charting in */
    chart_sizes() {
        let width = Math.max(chart_min_width, $(this.container).width()  - margin.left - margin.right);
        return {
            width: width,
            height: height,
        };
    }

    resize = (no_debounce:boolean = false) => {
        if (this.destroyed) {
            return;
        }

        if (this.resize_debounce) {
            clearTimeout(this.resize_debounce);
            this.resize_debounce = null;
        }

        if (!no_debounce) {
            this.resize_debounce = setTimeout(() => this.resize(true), 10);
            return;
        }

        this.setRanges();
        let width = this.graph_width;

        this.svg.attr('width', this.width + margin.left + margin.right);
        this.svg.attr('height', height + margin.top + margin.bottom + 60);
        this.clip.attr('width', width);
        //this.clip.attr('height', height);

        //this.legend.attr('width', width);
        //this.legend.attr('height', 30);

        //this.range_label.attr('transform', 'translate(' + width + ', 0)');
        //this.x_axis_date_labels.attr('transform', 'translate(0 ,' + height + ')');
        //this.y_axis_rating_labels.attr('transform', 'translate(0, 0)');

        //this.verticalCrosshairLine.attr('y1', height);
        this.helper.attr('transform', 'translate(' + width + ', 0)');
        this.horizontalCrosshairLine.attr('x1', width);
        this.mouseArea.attr('width', width);
        this.mouseArea.attr('height', height);
        //this.timeline_axis_labels.attr('transform', 'translate(0,' + (secondary_charts_height - 22) + ')');
        //this.timeline_axis_labels.call(this.timeline_axis);
        //this.brush.extent([[0, 0], [width, secondary_charts_height]]);

        let graph_right_side = this.graph_width + margin.left + margin.right;

    }

    /* Callback function for data retrieval, which plots the retrieved data */
    loadDataAndPlot = (data) => {
        if (!data || data.length === 1) {
            this.setState({
                loading: false,
                nodata: true,
            });
        } else {
            this.setState({
                loading: false,
                nodata: false,
            });
        }

        //this.game_entries = data || [];
        //this.game_entries.reverse();

        this.predictions = new Array<AnalysisEntry>();
        for (let i=0; i < data.length; ++i) {
            this.predictions.push(new AnalysisEntry(data[i]));
        }

        /* Plot graph */
        let move_range:any = d3.extent(this.predictions.map((d:AnalysisEntry) => { return d.move; }));

        this.prediction_x.domain(move_range);
        this.prediction_y.domain([0.0, 1.0]);
        //let game_count_extent = d3.extent(this.games_by_month.map((d:AnalysisEntry) => { return d.count; }));
        //game_count_extent[0] = 0;
        //this.outcomes_y.domain(d3.extent(game_count_extent));
        //this.timeline_x.domain(this.prediction_x.domain());
        //this.timeline_y.domain(d3.extent(this.game_entries.map((d:AnalysisEntry) => { return humble_rating(d.rating, d.deviation); })) as any);
        //this.date_extents = this.timeline_x.range().map(this.timeline_x.invert, this.timeline_x);
        //this.setState({date_extents: this.date_extents.slice()});
        this.range_label.text(move_range[0] + ' - ' + move_range[1]);
        this.prediction_chart
            .datum(this.predictions)
            .attr('d', this.prediction_line as any);
        //this.x_axis_date_labels.call(this.selected_axis);
        //this.y_axis_rating_labels.call(this.rating_axis);
    }

    setContainer = (e) => {
        let need_resize = this.container === null;
        this.container = e;
        if (need_resize) {
            this.resize();
        }
    }

    render() {
        console.log("rendering");
        return (
            <div ref={this.setContainer} className="AnalysisPredictionChart">
                {this.state.loading
                    ? <div className='loading'>{_("Loading")}</div>
                    : this.state.nodata
                        ? <div className='nodata'>{_("No rated games played yet")}</div>
                        : <div className='ratings-graph'>
                            <PersistentElement elt={this.chart_div}/>
                        </div>
                }
            </div>
        );
    }
}
